# Workflow Gates: High-Level Design

**Version:** 1.0  
**Author:** Architect  
**Date:** 2026-02-16  
**Status:** Draft — Awaiting PO/PM Review  
**Context:** Operational findings — response to missing enforcement of multi-stage process gates

---

## Executive Summary

Workflow Gates is a **domain-neutral primitive** for enforcing multi-stage processes with review gates, rejection loops, and conditional progression. It enables projects to define deterministic workflows (implement → review → test → approve) while keeping agents simple: they receive work, complete it, and signal outcomes — routing is automatic.

**Design principles:**
- **Agent-simple**: One API call (`aof_task_complete`), no workflow knowledge required
- **Human-simple**: ~10 lines of YAML for basic workflows
- **Domain-neutral**: Works for SWE, sales, content, compliance — anything with staged progression
- **Deterministic**: Gate routing is pure TypeScript, no LLM calls in control plane
- **Observable**: Every transition logged, metrified, and auditable

---

## 1. Core Abstractions

### 1.1 Gate

A **gate** is a discrete stage in a workflow where work is assigned to a specific role for action.

**Properties:**
- `id` (string): Unique identifier within workflow (e.g., "implement", "review", "approve")
- `role` (string): Role assigned to this gate (maps to agents via org chart)
- `canReject` (boolean): Whether this gate can send work back to previous gates
- `when` (expression, optional): Conditional logic for gate activation
- `description` (string, optional): Human-readable purpose
- `requireHuman` (boolean, optional): Whether only humans can complete this gate (v1)
- `timeout` (duration, optional): Max time before auto-escalation (v1)
- `escalateTo` (string, optional): Role to escalate to on timeout (v1)

**Characteristics:**
- Gates are **stateless** — they define *what happens*, not current state
- Gates are **role-based** — assignment is indirect (role → agents via org chart)
- Gates can be **conditional** — skipped based on task metadata
- Gates can be **reviewable** — reviewers can approve or reject with feedback
- Gates can **time out** — auto-escalate to supervisor/fallback role after threshold
- Gates can **require human approval** — agents cannot complete, only humans

### 1.2 Workflow

A **workflow** is an ordered sequence of gates that defines the complete lifecycle for a class of tasks.

**Properties:**
- `gates` (array): Ordered list of gate definitions
- `defaultOutcome` (string): What "complete" means if agent doesn't specify (default: "complete")
- `rejectionStrategy` (string): How far to loop back on rejection ("previous" | "origin" | "named")

**Characteristics:**
- Workflows are **project-scoped** — defined once in `project.yaml`
- Workflows are **deterministic** — progression logic is evaluable without LLM calls
- Workflows are **composable** — same primitive works across domains

### 1.3 Gate Progression

**Progression** is the act of moving a task through gates, triggered by agent completion signals.

**Mechanics:**
- Agent completes work at current gate
- Scheduler evaluates outcome (complete | needs_review | blocked)
- If complete: evaluate next gate (skip if conditional fails, advance if active)
- If needs_review: evaluate rejection strategy, loop back to target gate
- Route task to agents with appropriate role
- Log transition, emit telemetry

**Key insight:** Progression is **event-driven** (completion signal) but **deterministically routed** (no agent decides next gate).

---

## 2. Data Model

### 2.1 Task Frontmatter (Extended)

Tasks gain new fields to track gate state:

```yaml
# Unique task identifier (generated by AOF)
id: AOF-abc  # Immutable ID used for routing/history

# Human-readable title
title: Implement user authentication  # Short, descriptive name

# One of: ready, in_progress, blocked, complete
status: in_progress  # Current lifecycle state

# ISO8601 timestamps
created: 2026-02-16T10:00:00Z  # When task was created
updated: 2026-02-16T15:00:00Z  # Last update timestamp

# Routing determines who gets this task
routing:  # Routing determines assignment
  role: backend       # Current gate's role (used for agent assignment)
  workflow: default   # Workflow name from project.yaml
  agent: agent-7      # Currently assigned agent (optional)

# Current gate state
gate:  # Current gate state
  current: implement          # Current gate ID (matches workflow gate)
  entered: 2026-02-16T10:00:00Z  # When task entered this gate

# Complete audit trail of all gate transitions (append-only, stored in frontmatter)
gateHistory:  # Append-only audit trail
  - gate: implement           # Gate ID
    role: backend             # Gate's assigned role
    agent: agent-7            # Agent who worked on this
    entered: 2026-02-16T10:00:00Z  # When agent entered gate
    exited: 2026-02-16T14:30:00Z   # When agent completed gate
    outcome: complete         # Result: complete | needs_review | blocked
    summary: "Implemented JWT middleware with tests"  # Agent summary
    blockers: []              # Blockers if needs_review/blocked
    rejectionNotes: ""        # Extra context if needs_review
    duration: 16200           # Seconds in gate (for metrics)

  - gate: code-review          # Gate ID
    role: architect            # Gate's assigned role
    agent: agent-3             # Agent who reviewed
    entered: 2026-02-16T14:30:00Z  # Entered review gate
    exited: 2026-02-16T15:00:00Z   # Exited review gate
    outcome: needs_review      # Rejected - loop back
    summary: "Implementation needs revision"  # Reviewer summary
    blockers:                  # Actionable issues to fix
      - "Missing error handling for expired tokens"
      - "Test coverage at 65%, need 80%+"
    rejectionNotes: "Please address blockers and resubmit"  # Reviewer notes
    duration: 1800             # Seconds in gate

  - gate: implement            # Looped back after rejection
    role: backend              # Gate role
    agent: agent-7             # Assigned agent
    entered: 2026-02-16T15:00:00Z  # Re-entered implement
    # Still in progress - no exited/outcome yet
    reviewContext:             # Feedback from previous rejection
      fromGate: code-review    # Gate that rejected
      fromAgent: agent-3       # Rejecting agent
      fromRole: architect      # Rejecting role
      timestamp: 2026-02-16T15:00:00Z  # Rejection time
      blockers:                # Copied blockers
        - "Missing error handling for expired tokens"
        - "Test coverage at 65%, need 80%+"
      notes: "Please address blockers and resubmit"  # Copied notes

# Optional: BDD-style test specs (designed for future executability)
# If tests exceed ~20 specs, move to testsFile

tests:  # Optional BDD-style test specs
  - given: "Valid JWT token in Authorization header"  # Precondition
    when: "POST /api/protected"                      # Action
    then:  # Expected outcomes
      status: 200                                    # Expected status
      body_contains: ["success"]                    # Expected body substrings

  - given: "Expired JWT token"
    when: "POST /api/protected"
    then:  # Expected outcomes
      status: 401
      body_contains: ["expired", "token"]

  - given: "No Authorization header"
    when: "POST /api/protected"
    then:  # Expected outcomes
      status: 401
      body_contains: ["missing", "token"]

# Optional: Reference to external test file (if tests too large for frontmatter)
# testsFile: TASK-abc.tests.yaml  # Path to companion tests file

# Task classification
tags: [auth, security]  # Used in gate conditionals

# Free-form metadata (available in gate conditionals)
metadata:  # Free-form metadata
  priority: high        # Task priority used for routing/alerts
  complexity: medium    # Heuristic complexity tag
```

**Key fields:**
- `gate.current`: Active gate ID
- `gate.entered`: When task entered this gate (for duration metrics and timeout detection)
- `gateHistory[]`: **Append-only log of every gate transition stored in frontmatter** (D1)
- `reviewContext`: Carried forward when rejected, provides feedback to agent
- `tests[]`: Optional BDD-style test specifications designed for future executability (C6)

### 2.2 Workflow Configuration Schema

Defined in `project.yaml`:

```yaml
workflow:  # Workflow definition
  # Unique identifier for this workflow (allows multiple per project)
  name: default  # Referenced by routing.workflow in tasks

  # Rejection loop-back strategy (D4: v1 uses implement)
  rejectionStrategy: origin  # All rejections return to first gate (implement)

  # Ordered sequence of gates (tasks progress through in order)
  gates:  # Ordered gate list
    # Implementation gate - where work is produced
    - id: implement            # Gate ID used in task.gate.current
      role: backend            # Role from org.yaml that handles this gate
      description: "Initial implementation with tests"  # Human-readable purpose
      timeout: 2h              # D2: implement gate timeout (auto-escalate after 2h)
      escalateTo: architect    # Role to escalate to on timeout

    # Code review gate - architect checks quality
    - id: code-review  # Gate ID
      role: architect
      canReject: true          # Gate may return task for fixes
      description: "Architecture and code quality review"
      timeout: 1h              # D2: review gate timeout (auto-escalate after 1h)
      escalateTo: tech-lead    # Escalation role if reviewer doesn't respond

    # QA gate - functional testing
    - id: test  # Gate ID
      role: qa
      canReject: true          # QA may reject to implement
      description: "Functional and integration testing"
      when: "!tags.includes('skip-qa')"  # Skip if task tagged skip-qa
      timeout: 1h              # D2: review gate timeout
      escalateTo: qa-lead       # Escalation role for QA delays

    # Security audit - conditional on security-sensitive tasks
    - id: security  # Gate ID
      role: security
      canReject: true
      description: "Security review for sensitive changes"  # Purpose shown to agents
      when: "tags.includes('security') || tags.includes('auth')"  # Conditional gate
      timeout: 1h              # D2: review gate timeout
      escalateTo: security-lead  # Escalation role for security delays

    # Documentation gate - conditional on API changes
    - id: docs  # Gate ID
      role: tech-writer
      description: "Update docs for API or UX changes"  # Gate purpose
      when: "tags.includes('api') || tags.includes('docs')"  # Conditional gate
      timeout: 1h              # D2: review gate timeout
      escalateTo: docs-lead     # Escalation role for docs delays

    # Final approval - PO sign-off (human-only in v1)
    - id: approve  # Gate ID
      role: po
      description: "Final acceptance"  # Approval criteria gate
      requireHuman: true       # D3: only humans can complete this gate
      timeout: 1h              # D2: review gate timeout (agents still escalate if idle)
      escalateTo: director      # Escalation role if PO unavailable

  # What each outcome means (helps agents understand)
  outcomes:  # Outcome meaning map
    complete: advance          # Move to next gate
    needs_review: reject       # Loop back to implement (D4)
    blocked: hold              # Keep in current gate, signal blocker
```

**Validation rules:**
- First gate cannot have `canReject: true` (nothing to loop back to)
- `when` expressions must be valid JavaScript predicates
- All `role` values must exist in org chart
- Gate IDs must be unique within workflow
- `timeout` must be valid duration string (e.g., "1h", "30m", "2h")
- `escalateTo` role must exist in org chart if specified
- `requireHuman: true` gates still require timeout + escalation (D2); v1 uses 1h review timeout

### 2.3 Outcome Types

When agents call `aof_task_complete(outcome, context)`:

| Outcome | Meaning | Gate Action |
|---------|---------|-------------|
| `complete` | Work done, ready for next stage | Advance to next gate |
| `needs_review` | Work needs revision | Reject to implement gate (D4: simplified v1 routing) |
| `blocked` | External blocker, can't proceed | Hold in current gate, log blocker |
| `skip` | Gate not applicable (conditional) | Skip to next gate (rare, usually auto-evaluated) |

**Rejection routing (D4):**
In v1, all rejections route back to the **implement** gate (first gate in workflow). This simplifies rejection logic:
- Code review rejects → back to implement
- QA rejects → back to implement
- Security rejects → back to implement
- No complex "which gate?" logic needed

**Rejection payload:**
```typescript
{
  outcome: "needs_review",
  summary: "Implementation needs revision",
  blockers: [
    "Missing error handling in auth middleware",
    "Test coverage at 65%, target is 80%"
  ],
  rejectionNotes: "Please address blockers and resubmit"
}
```

**Note:** Future versions may support more sophisticated rejection routing (previous gate, origin, named target). V1 keeps it simple.

---

## 3. Control Flow

### 3.1 Gate Evaluation Algorithm

When scheduler processes a task completion:

```
1. Load task from storage
2. Load project workflow config
3. Identify current gate from task.gate.current
4. Parse agent's outcome from completion signal
5. IF outcome = "complete":
     a. Find next gate in workflow.gates after current
     b. WHILE next gate exists AND next.when evaluates to false:
          i. Log skipped gate
          ii. Advance to next gate
     c. IF next gate exists:
          i. Update task.gate.current = next.id
          ii. Update task.routing.role = next.role
          iii. Append entry to task.gateHistory
          iv. Route task to agents with next.role
     d. ELSE (no more gates):
          i. Mark task complete
          ii. Archive task
6. ELSE IF outcome = "needs_review":
     a. Target gate is always the first gate in workflow (implement) (D4)
     b. Append rejection entry to gateHistory
     c. Attach reviewContext with blockers
     d. Update task.gate.current = first gate
     e. Route to agents with first gate role
7. ELSE IF outcome = "blocked":
     a. Keep task in current gate
     b. Emit telemetry (blocked_task metric)
     c. Notify project stakeholders
8. Log transition to event stream
9. Emit telemetry (gate_duration, transition counts)
```

**Key properties:**
- **Deterministic**: No LLM calls, pure JavaScript evaluation
- **Idempotent**: Re-running with same outcome produces same result
- **Atomic**: Task update + history append + routing in single transaction

### 3.2 Conditional Gate Logic

Gates with `when` expressions are evaluated **before** assignment:

```yaml
- id: security  # Gate ID
  role: security  # Role from org.yaml
  when: "tags.includes('security') || tags.includes('auth')"  # Conditional gate
```

**Evaluation context:**
- `tags`: Task tags array
- `metadata`: Task metadata object
- `gateHistory`: Array of previous gate entries (for "was this reviewed already?" logic)

**Expression engine:**
- Use `vm.runInNewContext()` or similar sandboxed JS eval
- Whitelist safe operations (array methods, boolean logic, property access)
- Disallow function calls except whitelisted builtins
- Timeout expressions at 100ms

**Error handling:**
- Invalid expression → log error, treat as `when: false` (skip gate)
- Undefined property access → treat as falsy
- Exception during eval → skip gate, alert project owner

### 3.3 Rejection Routing (V1)

**Decision (D4):** All `needs_review` outcomes route back to the **implement** gate (first gate in workflow).

```
implement ← review ← test ← security ← docs
   ↑         (needs_review anywhere returns here)
   └───────────────────────────────────────────
```

**Why:** Simpler for agents and covers the majority of real-world cases. V2 may introduce configurable strategies (previous/origin/named) if needed.

### 3.4 Race Condition Handling

**Scenario:** Two agents complete the same gate simultaneously.

**Solution:** Optimistic locking via file modification timestamps.

```
1. Agent A completes gate at T1
2. Agent B completes gate at T2 (T2 > T1)
3. Scheduler A reads task, evaluates next gate, writes update
4. Scheduler B reads task:
   a. IF task.gate.current != expected current gate:  # Current gate state
        - Log conflict
        - Discard B's completion (A won)
        - Notify agent B that task has moved
   b. ELSE:
        - Process normally (A's update hadn't landed yet)
```

**Alternative (stronger):** Advisory file locks during gate transitions (flock on Unix).

**Observability:** Emit `gate_conflict` metric when races detected.

---

## 4. Agent Interface (Dumb-Agent-First Design)

**Core Principle (C1):** An agent with zero AOF training and modest capability must get massive value out of the box. Tool descriptions teach usage. Gate context teaches expectations. No external docs required.

### 4.1 Tool Description (Self-Teaching)

The `aof_task_complete` tool description is designed to teach correct usage on first encounter:

```typescript
// Tool registration in AOF protocol
{
  name: "aof_task_complete",
  description: `Mark your current task as done.

**When to use:**
- You've finished your work and it's ready for the next step: set outcome to "complete"
- You found problems that need someone else to fix: set outcome to "needs_review" and list blockers
- You can't proceed due to external blockers: set outcome to "blocked" and explain why

**Parameters:**
- outcome (required): "complete" | "needs_review" | "blocked"
  - "complete": Your work is done and ready to advance
  - "needs_review": Work needs fixes - include specific blockers
  - "blocked": Can't proceed - external dependency or blocker
  
- summary (required): Brief description of what you did (1-2 sentences)

- blockers (optional, array of strings): Specific issues that need fixing
  - Required if outcome is "needs_review" or "blocked"
  - Each blocker should be actionable (not vague)
  - Examples: "Missing error handling for expired tokens", "Test coverage at 65%, need 80%"
  
- rejectionNotes (optional, string): Additional context for the person fixing issues
  - Only relevant for "needs_review" outcome
  - Keep it constructive and specific

**Examples:**

Complete:
{
  "outcome": "complete",
  "summary": "Implemented JWT middleware with tests, 85% coverage"
}

Needs Review (reviewer rejecting work):
{
  "outcome": "needs_review",
  "summary": "Implementation needs revision before advancing",
  "blockers": [
    "Missing error handling for expired tokens",
    "Test coverage at 65%, target is 80%"
  ],
  "rejectionNotes": "Please address these issues and resubmit"
}

Blocked (can't proceed):
{
  "outcome": "blocked",
  "summary": "Waiting for API spec from external team",
  "blockers": ["Need finalized API spec from platform team"]
}`,

  parameters: {
    type: "object",
    properties: {
      outcome: {
        type: "string",
        enum: ["complete", "needs_review", "blocked"],
        description: "Result of your work"
      },
      summary: {
        type: "string",
        description: "What you did (required)"
      },
      blockers: {
        type: "array",
        items: { type: "string" },
        description: "Specific issues (required for needs_review/blocked)"
      },
      rejectionNotes: {
        type: "string",
        description: "Additional context for needs_review"
      }
    },
    required: ["outcome", "summary"]
  }
}
```

**Key insight:** The tool description is **complete documentation**. An agent reading this knows:
- When to use each outcome
- What parameters are required
- How to format blockers
- What constitutes good vs. bad usage

No SKILL.md needed. No external docs needed. The tool teaches itself.

### 4.2 Gate Context Injection (Task-Level Teaching)

When AOF assigns a task, it injects gate-specific context that tells the agent **exactly** what's expected:

**Example 1: Implementation Gate**
```yaml
# Task as received by backend agent
id: AOF-abc  # Task ID
title: Implement user authentication  # Task title
description: Add JWT-based authentication to API  # Task description

# Gate context injected by AOF scheduler
gate_context:  # Gate-specific instructions
  role: "You are implementing this feature from scratch."  # Plain-language role
  gate: implement  # Current gate ID
  expectations:  # Checklist for this gate
    - "Write production code that solves the requirement"
    - "Write tests BEFORE implementation (TDD)"
    - "Achieve >= 80% test coverage"
    - "Keep functions under 120 LOC, files under 500 LOC"
    - "Include error handling for edge cases"

  outcomes:  # What each outcome means at this gate
    complete: "Your code and tests are done. It will advance to code review."
    blocked: "You can't proceed (e.g., missing spec, external dependency). List what's blocking you."

  tips:  # Optional guidance for success
    - "Check git timestamps to prove tests were written first"
    - "Run coverage report before marking complete"

# Standard task fields
routing:  # Assignment routing
  role: backend   # Assigned role
  workflow: default  # Workflow name
```

**Example 2: Code Review Gate**
```yaml
# Task as received by architect agent
id: AOF-abc  # Task ID
title: Implement user authentication  # Task title

# Gate context injected by AOF scheduler
gate_context:  # Gate-specific instructions
  role: "You are reviewing this code for quality and architecture compliance."  # Role guidance
  gate: code-review  # Current gate ID
  expectations:  # Review checklist
    - "Verify tests were written BEFORE implementation (check git timestamps)"
    - "Check test coverage >= 80% for new code"
    - "Check for files > 500 LOC or functions > 120 LOC (size budget violation)"
    - "Verify error handling for edge cases"
    - "Check for security issues (SQL injection, XSS, auth bypasses)"

  outcomes:  # Outcome meanings for this gate
    complete: "Code passes review. It will advance to QA."
    needs_review: "Code needs fixes. List specific blockers. It will go back to the implementer."

  tips:  # Practical guidance for reviewers
    - "Be specific in blockers - 'low test coverage' is vague, 'test coverage at 65%, need 80%' is actionable"
    - "One blocker per issue for clarity"

routing:  # Assignment routing
  role: architect  # Assigned role
  workflow: default  # Workflow name
```

**Example 3: Task with Review Context (Looped Back)**
```yaml
# Task as received by backend agent after rejection
id: AOF-abc  # Task ID
title: Implement user authentication  # Task title

gate_context:  # Gate-specific instructions
  role: "You are fixing issues from a previous review."  # Role guidance
  gate: implement  # Current gate ID
  expectations:  # Fix-up checklist
    - "Address ALL blockers listed in reviewContext below"
    - "Don't introduce new issues while fixing"
    - "Re-run tests and coverage checks"

  outcomes:  # Outcome meanings for this gate
    complete: "Blockers addressed. It will go back to code review."
    blocked: "Can't fix blockers (e.g., need clarification). Explain why."

# Review feedback from previous rejection
reviewContext:  # Feedback from previous rejection
  fromGate: code-review  # Gate that rejected
  fromAgent: agent-3     # Rejecting agent
  fromRole: architect    # Rejecting role
  timestamp: 2026-02-16T15:00:00Z  # Rejection time
  blockers:              # Actionable issues to fix
    - "Missing error handling for expired tokens"
    - "Test coverage at 65%, need 80%+"
  notes: "Please address these issues and resubmit"  # Reviewer notes

routing:  # Assignment routing
  role: backend   # Assigned role
  workflow: default  # Workflow name
```

**Key insight:** Gate context is **progressive disclosure**:
- Agent sees only what's relevant to THIS gate
- Expectations are concrete checklists, not vague guidance
- Outcomes are explained in plain language
- Tips provide practical guidance

No need to understand the full workflow. Just follow the checklist, pick the right outcome.

### 4.3 Agent Contract (Zero Workflow Knowledge)

Agents interact with gates **indirectly** — they never see workflow config or routing logic:

```typescript
// Agent receives task with gate context injected
const task = await aof.getTask();

// Gate context tells agent what to do
console.log("My role:", task.gate_context.role);
console.log("Expectations:", task.gate_context.expectations);

// If looped back from review, context includes feedback
if (task.reviewContext) {
  console.log("Previous review feedback:");
  task.reviewContext.blockers.forEach(b => console.log(`  - ${b}`));
}

// Agent does work
await doWork(task);

// Agent signals completion (routing happens automatically)
await aof.taskComplete({
  outcome: "complete",
  summary: "Implemented JWT auth with error handling, 85% test coverage"
});

// AOF automatically:
// - Evaluates next gate (no agent involvement)
// - Routes to next role (no agent involvement)
// - Logs transition (observable)
// - Emits telemetry (metrics)
```

**What agents NEVER do:**
- Know what gates exist in the workflow
- Decide which gate to route to next
- Parse workflow configuration
- Manually assign tasks to other agents
- Understand rejection loop-back logic

**What agents ALWAYS do:**
- Follow the checklist in gate_context.expectations
- Pick the outcome that matches their situation
- Provide specific, actionable blockers when rejecting
- Write a clear summary of what they did

**Key insight:** Agents are **pure workers**. They receive work, do work, signal done. All routing logic is AOF's responsibility.

### 4.4 Agent Contract (Zero Workflow Knowledge)

Agents interact with gates **indirectly** — they never see workflow config or routing logic. See Section 5 for the progressive disclosure ladder that teaches agents without context pollution.

---

## 5. Progressive Disclosure (Teaching Without Context Pollution)

**Core Principle (C3 + C4):** AOF must teach agents idiomatically without injecting instruction walls. Teaching escalates from lightweight to comprehensive, but ONLY when needed.

### 5.1 The Teaching Ladder

```
Level 1: Tool Descriptions (always present, zero cost)
   ↓
Level 2: Per-Task Gate Context (only when relevant)
   ↓
Level 3: Helpful Errors (only on mistakes)
   ↓
Level 4: Optional Cheatsheet (power users only)
```

**Key insight:** If an agent needs a SKILL.md to use AOF, **the design has failed**.

A SKILL.md CAN exist for:
- Power users who want deep understanding
- Orchestrator agents that coordinate multiple roles
- Agents introspecting workflow state for advanced features

But it's **optional** for 80%+ of workflows. Basic agents thrive without it.

### 5.2 Level 1: Tool Descriptions

Tool descriptions are **embedded documentation** — read once per session, teach forever.

**Design principle:** A tool description must be so clear that any agent uses it correctly on first encounter.

**Bad example (requires external knowledge):**
```
"Signal task completion with gate-aware outcome routing"
```

**Good example (self-teaching):**
```
"Mark your current task as done. Set outcome to 'complete' if your work is finished, 
'needs_review' if you found problems that need someone else to fix, or 'blocked' if 
you can't proceed. Include a summary of what you did."
```

See Section 4.1 for full `aof_task_complete` tool description.

### 5.3 Level 2: Per-Task Gate Context

Gate context is injected **only for the current task** — no noise about other gates or workflow topology.

**What's included:**
- **Role explanation:** "You are reviewing this code for quality"
- **Expectations checklist:** Concrete, testable criteria
- **Outcomes explained:** What each outcome means at THIS gate
- **Tips:** Practical guidance (e.g., "Check git timestamps for TDD")

**What's NOT included:**
- Full workflow definition
- Other gates' expectations
- Routing logic or rejection strategies
- Historical context beyond current review feedback

**Example:** See Section 4.2 for gate context injection examples.

### 5.4 Level 3: Helpful Errors

Every invalid action produces an **actionable, teaching error message** — not a cryptic failure.

**Principles:**
- Tell agent what went wrong
- Tell agent how to fix it
- Provide concrete examples if helpful
- Never silently fail or return vague errors

**Example catalog:**

| Invalid Action | Error Message |
|----------------|---------------|
| Invalid outcome | `Invalid outcome "done". Valid outcomes: "complete", "needs_review", "blocked". Use "complete" if your work is finished.` |
| Missing summary | `Missing required field "summary". Please include a 1-2 sentence description of what you did.` |
| Missing blockers | `Outcome "needs_review" requires "blockers" field. List specific issues that need fixing (e.g., ["Missing error handling", "Test coverage at 65%"]).` |
| Wrong task | `You're trying to complete task AOF-xyz but you're assigned to AOF-abc. Did you mean to complete AOF-abc?` |
| Empty blockers array | `"blockers" is an empty array. If outcome is "needs_review" or "blocked", list at least one specific issue.` |
| Vague blocker | `Blocker "needs work" is too vague. Be specific: what exactly needs fixing? Example: "Missing error handling for timeout edge case"` |

See Section 9 for complete error catalog.

### 5.5 Level 4: Optional Cheatsheet (Power Users)

A **SKILL.md** can exist for advanced usage, but it's NOT required for basic workflows.

**Who needs it:**
- Orchestrator agents coordinating multiple roles
- Agents implementing custom workflow introspection
- Power users wanting to understand internal mechanics

**Who DOESN'T need it:**
- Backend agents implementing features (follow gate context)
- QA agents running tests (follow gate context)
- Review agents checking quality (follow gate context)
- 80%+ of all AOF interactions

**What it contains:**
- Workflow config schema deep dive
- Org chart mapping details
- Advanced telemetry queries
- Custom gate conditionals
- Debugging stuck workflows

**What it DOESN'T contain:**
- Basic usage (covered by tool descriptions)
- Gate-specific expectations (covered by gate context)
- Error recovery (covered by helpful errors)

**Design validation:** If basic agents fail without SKILL.md, the tool descriptions and gate context are insufficient. Fix those first.

### 5.6 Self-Documenting Configuration (C3)

All YAML examples in this document include **inline comments** explaining each field. A human or agent reading the config should understand it without external docs.

**Principle:** Configuration is code. It should be readable, documented, and self-explanatory.

See Section 2.2 for fully commented workflow config examples.  
See Section 6.3.5 for a fully commented org chart example.

## 6. Integration Points

### 6.1 Scheduler Changes

**Current scheduler:**
- Reads tasks by status (ready, in_progress)
- Assigns based on `routing.agent` or `routing.role`
- No concept of multi-stage progression

**Gate-aware scheduler:**

1. **Task dispatch:**
   - Read `task.gate.current` and `project.workflow`
   - Evaluate conditional gates (skip if `when: false`)
   - Assign to agents with `routing.role` for current gate
   - Inject gate context into task payload

2. **Completion handling:**
   - Parse outcome from `aof_task_complete`
   - Run gate evaluation algorithm (section 3.1)
   - Update task frontmatter atomically
   - Route to next gate or loop back
   - Emit telemetry

3. **Backlog queries:**
   - Filter tasks by gate (e.g., "all tasks in code-review gate")
   - Group by gate for dashboard metrics
   - Compute gate durations (time since `gate.entered`)

**New scheduler method:**
```typescript
async handleGateTransition(
  taskId: string,
  outcome: GateOutcome,
  context: CompletionContext
): Promise<GateTransition> {
  // Load task + workflow
  // Evaluate next gate
  // Update task state
  // Route to next role
  // Return transition for logging
}
```

### 6.2 Protocol Changes

**Existing `aof_task_complete`:**
```typescript
await aof.taskComplete({
  summary: "Implemented feature X"
});
```

**Extended for gates:**
```typescript
await aof.taskComplete({
  outcome: "complete" | "needs_review" | "blocked",
  summary: "Human-readable completion summary",
  blockers?: string[],           // For needs_review or blocked
  rejectionNotes?: string,       // For needs_review
  metadata?: Record<string, any> // For telemetry
});
```

**Backward compatibility:**
- If `outcome` omitted, default to `"complete"`
- Existing agents work unchanged (implicit "complete" advances gate)

**Protocol message mapping:**

| Protocol Message | Gate Action |
|------------------|-------------|
| `completion.report` | Trigger gate evaluation |
| `handoff.initiate` | (Deprecated by gates — routing is automatic) |
| `status.update` | Update gate metrics, no state change |

### 6.3 Org Chart Integration (C5: Self-Documenting)

Gates reference **roles**, not agents. The org chart provides role → agents mapping.

#### 6.3.1 Why Roles, Not Agents?

**Problem:** Hardcoding agent IDs in workflow config breaks when agents change.

**Solution:** Workflow references abstract roles. Org chart maps roles to concrete agents. Change agents without changing workflow.

#### 6.3.2 Org Chart Configuration

Defined in `org.yaml` at project root:

```yaml
# Org chart maps abstract roles to concrete agent instances
# Roles are referenced in workflow gates (project.yaml)
# When AOF routes a task to a role, it assigns to one of that role's agents

roles:  # Role map
  # Backend role: implements features, writes code
  backend:
    agents:
      - agent-backend-1    # Agent instance ID (from AOF registry)
      - agent-backend-2    # Second backend agent for load balancing
    description: "Implements features and writes tests"  # Role purpose

  # Architect role: reviews code for quality and architecture
  architect:
    agents:
      - agent-architect-1  # Single specialist agent
    description: "Code review and architecture oversight"  # Role purpose

  # QA role: tests implementations
  qa:
    agents:
      - agent-qa-1         # QA agent 1
      - agent-qa-2         # QA agent 2
    description: "Functional and integration testing"  # Role purpose

  # Security role: security audits (conditional gate)
  security:
    agents:
      - agent-security-1   # Security specialist
    description: "Security review for auth/sensitive code"  # Role purpose

  # Tech writer role: documentation (conditional gate)
  tech-writer:
    agents:
      - agent-docs-1       # Docs specialist
    description: "API documentation and user guides"  # Role purpose

  # Product owner: final approval (human-only gate)
  po:
    agents:
      - human-xav          # Humans are agents too (human- prefix)
    description: "Product owner for acceptance decisions"  # Role purpose
    requireHuman: true     # Enforce human-only for this role
```

#### 6.3.3 Mapping Gates to Roles

**Workflow gate** (in `project.yaml`):
```yaml
gates:  # Ordered gate list
  - id: code-review       # Gate ID
    role: architect       # References org chart role
    canReject: true       # Allows rejection to implement
```

**Org chart** (in `org.yaml`):
```yaml
roles:  # Role map
  architect:
    agents:
      - agent-architect-1  # Architect agent mapped to role
```

**Scheduler routing logic:**
1. Task reaches "code-review" gate
2. Gate config says `role: architect`
3. Org chart maps "architect" to `[agent-architect-1]`
4. Scheduler assigns task to `agent-architect-1`

#### 6.3.4 Common Patterns

**Pattern 1: Single Agent Per Role** (specialist)
```yaml
roles:  # Role map
  architect:
    agents:
      - agent-architect-1   # Single architect agent for this role
```
Use when: Role requires specific expertise, low task volume.

**Pattern 2: Multiple Agents Per Role** (load balancing)
```yaml
roles:  # Role map
  backend:
    agents:
      - agent-backend-1     # Backend agent 1
      - agent-backend-2     # Backend agent 2
      - agent-backend-3     # Backend agent 3 (load balancing)
```
Use when: High task volume, work is parallelizable.  
**Scheduler behavior:** Round-robin or least-loaded assignment.

**Pattern 3: Shared Roles** (cross-functional)
```yaml
roles:  # Role map
  generalist:
    agents:
      - agent-7           # Shared role (backend + QA + docs)
```
Use when: Small team, agents wear multiple hats.  
**Note:** Agent must have skills for all gates using this role.

**Pattern 4: Conditional Roles** (on-demand specialists)
```yaml
roles:  # Role map
  security:
    agents:
      - agent-security-1     # Security specialist agent

# In workflow:
gates:  # Ordered gate list
  - id: security             # Gate ID
    role: security           # Role maps to org.yaml
    when: "tags.includes('security')"  # Only for security-tagged tasks
```
Use when: Specialist needed only for subset of tasks.

**Pattern 5: Escalation Roles** (supervisors)
```yaml
roles:  # Role map
  architect:
    agents:
      - agent-architect-1   # Primary reviewer

  tech-lead:                # Escalation target role
    agents:
      - human-tech-lead     # Human fallback for timeouts

# In workflow:
gates:  # Ordered gate list
  - id: code-review          # Gate ID
    role: architect          # Primary role
    timeout: 1h              # D2 review timeout
    escalateTo: tech-lead    # Escalate if architect doesn't respond
```
Use when: Need backup for timeouts or bottlenecks.

#### 6.3.5 Full Org Chart Example (C5)

A full org chart showing **role → agent mapping** and common idioms (single/multiple/shared/conditional):

```yaml
# org.yaml (full example with inline comments)
roles:  # Role map
  backend:
    agents:
      - agent-backend-1      # Backend agent 1 (implementation)
      - agent-backend-2      # Backend agent 2 (load balancing)
    description: "Implements features and writes tests"  # Role purpose

  architect:
    agents:
      - agent-architect-1    # Single specialist reviewer
    description: "Architecture and code quality review"  # Role purpose

  generalist:
    agents:
      - agent-generalist-1   # Shared role: can do QA + docs
    description: "Cross-functional support role"  # Shared role pattern

  qa:
    agents:
      - agent-qa-1           # QA agent 1
    description: "Functional and integration testing"  # Role purpose

  tech-writer:
    agents:
      - agent-docs-1         # Docs specialist
    description: "Documentation and release notes"  # Role purpose

  security:
    agents:
      - agent-security-1     # Conditional specialist (only some tasks)
    description: "Security review for sensitive changes"  # Role purpose

  tech-lead:
    agents:
      - human-tech-lead      # Escalation target (human)
    description: "Escalation role for timeouts"  # Escalation role pattern

  po:
    agents:
      - human-xav            # Human-only approval
    description: "Product owner acceptance"  # Role purpose
    requireHuman: true       # Enforce human-only completion
```

#### 6.3.6 Adding/Removing Agents

**To add an agent to a role:**
1. Register agent in AOF agent registry
2. Add agent ID to `org.yaml` role
3. Reload org chart: `aof org reload` (or restart scheduler)
4. New agent starts receiving tasks for that role

**To remove an agent from a role:**
1. Remove agent ID from `org.yaml` role
2. Reload org chart
3. In-flight tasks assigned to that agent continue (don't interrupt)
4. New tasks route to remaining agents

**To change an agent's role:**
1. Remove from old role
2. Add to new role
3. Reload org chart
4. Agent immediately starts receiving new role's tasks

#### 6.3.7 Validation Rules

**On org chart load:**
- All roles referenced in workflow must exist in org chart
- All agent IDs must exist in AOF agent registry
- At least one agent per role (or workflow will stall)
- No duplicate agent IDs across roles (agent can't be in two roles... yet)

**Error handling:**
- Missing role → refuse to start scheduler, log validation error
- Missing agent ID → warn, exclude from assignment pool
- Empty role → warn, mark tasks as blocked with "no agents for role" error

#### 6.3.8 Example: Full Project Setup

**project.yaml**:
```yaml
workflow:  # Workflow definition
  name: default          # Workflow identifier
  rejectionStrategy: origin  # D4: all rejections return to first gate
  gates:  # Ordered gate list
    - id: implement      # Implementation gate
      role: backend      # Role from org.yaml
      timeout: 2h        # D2: implement timeout

    - id: code-review  # Gate ID
      role: architect    # Review role
      canReject: true    # Reviewer can send back to implement
      timeout: 1h        # D2: review timeout
      escalateTo: tech-lead  # Escalation role on timeout

    - id: test  # Gate ID
      role: qa           # QA role
      canReject: true    # QA can reject to implement
      timeout: 1h        # D2: review timeout

    - id: approve  # Gate ID
      role: po           # Product owner role
      requireHuman: true # D3: human-only approval
      timeout: 1h        # D2: review timeout
```

**org.yaml**:
```yaml
roles:  # Role map
  backend:
    agents: [agent-backend-1, agent-backend-2]  # Two backend agents

  architect:
    agents: [agent-architect-1]  # Single architect reviewer

  tech-lead:
    agents: [human-tech-lead]    # Escalation target (human)

  qa:
    agents: [agent-qa-1]          # QA agent

  po:
    agents: [human-xav]           # Product owner (human)
    requireHuman: true            # Enforce human-only completion
```

**Routing flow:**
1. Task created → `implement` gate → `backend` role → `agent-backend-1` (round-robin)
2. Agent completes → `code-review` gate → `architect` role → `agent-architect-1`
3. If architect doesn't complete in 1hr → escalate to `tech-lead` role → `human-tech-lead`
4. Architect approves → `test` gate → `qa` role → `agent-qa-1`
5. QA approves → `approve` gate → `po` role → `human-xav` (human-only)
6. PO approves → task complete

**Key insight:** Workflow is stable (doesn't change). Org chart is dynamic (agents come and go). Separation of concerns.

### 6.4 Telemetry Additions

**New Prometheus metrics:**

```typescript
// Gate durations
aof_gate_duration_seconds{project, workflow, gate, outcome}

// Gate transitions
aof_gate_transitions_total{project, workflow, from_gate, to_gate, outcome}

// Rejections
aof_gate_rejections_total{project, workflow, gate}

// Conditional skips
aof_gate_skips_total{project, workflow, gate, reason="condition_false"}

// Active tasks per gate
aof_gate_active_tasks{project, workflow, gate}

// Gate conflicts (race conditions)
aof_gate_conflicts_total{project, workflow, gate}
```

**Event stream (JSONL):**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "event": "gate_transition",
  "taskId": "AOF-abc",
  "project": "aof",
  "workflow": "default",
  "fromGate": "implement",
  "toGate": "code-review",
  "outcome": "complete",
  "agent": "agent-7",
  "duration": 14400,
  "summary": "Implemented JWT middleware with tests"
}
```

```json
{
  "timestamp": "2026-02-16T15:30:00Z",
  "event": "gate_rejection",
  "taskId": "AOF-abc",
  "project": "aof",
  "workflow": "default",
  "gate": "code-review",
  "targetGate": "implement",
  "agent": "agent-3",
  "blockers": ["Missing error handling", "Low test coverage"],
  "duration": 1800
}
```

### 6.5 Config Validation

**On project load:**
1. Parse `project.yaml` workflow section
2. Validate schema:
   - All `role` values exist in org chart
   - Gate IDs are unique
   - First gate doesn't have `canReject: true`
   - `when` expressions parse without syntax errors
   - Rejection strategy must be "origin" in v1 (D4)
3. If validation fails:
   - Log errors with line numbers
   - Refuse to start scheduler for this project
   - Emit `workflow_config_invalid` metric

**On workflow change (hot reload):**
- Re-validate config
- Check if any active tasks are at gates that no longer exist
- Migrate tasks to nearest valid gate or mark as needing manual intervention

---

## 7. Domain Neutrality

Gates must work for **any** staged process, not just software development.

### 7.1 Prohibited Terms (Domain-Specific)

Do NOT use in core abstractions or config keys:
- SDLC, sprint, story, epic, ticket
- Code, commit, PR, review, merge
- Deploy, release, build, CI/CD
- Bug, feature, hotfix

### 7.2 Generic Terminology

Use throughout implementation:

| Concept | Generic Term | SWE Example | Sales Example |
|---------|--------------|-------------|---------------|
| Stage | gate | code-review | qualify |
| Sequence | workflow, pipeline | SDLC | sales pipeline |
| Movement | progression, advance | merge to main | close deal |
| Return | rejection, loop-back | failed review | disqualified lead |
| Work unit | task | implement feature | prospect lead |
| Evaluator | reviewer, approver | architect | sales manager |

### 7.3 Configuration Examples

**Example 1: Software Development (Full Pipeline)**
```yaml
workflow:  # Workflow definition
  name: sdlc             # Workflow identifier
  rejectionStrategy: origin  # D4: rejections return to first gate
  gates:  # Ordered gate list
    - id: implement  # Gate ID
      role: backend       # Implementation role
      description: "Write code and tests"  # Gate purpose

    - id: code-review  # Gate ID
      role: architect     # Review role
      canReject: true     # Can reject to implement
      description: "Review for quality and architecture"

    - id: functional-test  # Gate ID
      role: qa            # QA role
      canReject: true     # Can reject to implement
      description: "Validate functionality"

    - id: security-audit  # Gate ID
      role: security      # Security role
      canReject: true     # Can reject to implement
      when: "tags.includes('security') || tags.includes('auth')"  # Conditional gate

    - id: docs  # Gate ID
      role: tech-writer   # Docs role
      when: "tags.includes('api')"  # Conditional gate

    - id: accept  # Gate ID
      role: po            # Product owner role
      description: "Final approval for release"  # Gate purpose
```

**Example 2: Sales Pipeline**
```yaml
workflow:  # Workflow definition
  name: sales            # Workflow identifier
  rejectionStrategy: origin  # Rejections return to first gate
  gates:  # Ordered gate list
    - id: prospect  # Gate ID
      role: sdr           # Sales development rep role
      description: "Initial lead contact"  # Gate purpose

    - id: qualify  # Gate ID
      role: sales-manager # Sales manager role
      canReject: true     # Can reject to prospect
      description: "Evaluate lead fit"

    - id: demo  # Gate ID
      role: ae            # Account executive role
      description: "Product demonstration"

    - id: proposal  # Gate ID
      role: ae            # Same role as demo
      description: "Send pricing proposal"

    - id: negotiate  # Gate ID
      role: sales-manager # Manager role
      canReject: true     # Can reject to prospect
      description: "Contract negotiation"
      when: "metadata.dealSize > 50000"  # Only for large deals

    - id: close  # Gate ID
      role: sales-director  # Final approver role
      description: "Final approval and signature"
```

**Example 3: Simple Two-Step Review**
```yaml
workflow:  # Workflow definition
  name: basic            # Workflow identifier
  rejectionStrategy: origin  # Rejections return to first gate
  gates:  # Ordered gate list
    - id: draft  # Gate ID
      role: writer        # Writer role
      description: "Create initial draft"  # Gate purpose

    - id: approve  # Gate ID
      role: editor        # Editor role
      canReject: true     # Can reject to draft
      description: "Editorial review"  # Gate purpose
```

**Example 4: Content Workflow**
```yaml
workflow:  # Workflow definition
  name: publishing        # Workflow identifier
  rejectionStrategy: origin  # Rejections return to first gate
  gates:  # Ordered gate list
    - id: draft  # Gate ID
      role: writer         # Writer role
      description: "Create draft"  # Gate purpose

    - id: editorial  # Gate ID
      role: editor         # Editor role
      canReject: true      # Can reject to draft
      description: "Editorial review"  # Gate purpose

    - id: fact-check  # Gate ID
      role: fact-checker   # Fact-checking role
      canReject: true      # Can reject to draft
      when: "tags.includes('news') || tags.includes('research')"  # Conditional gate
      description: "Verify factual accuracy"  # Gate purpose

    - id: legal  # Gate ID
      role: legal          # Legal role
      canReject: true      # Can reject to draft
      when: "tags.includes('legal-review')"  # Conditional gate
      description: "Legal compliance review"  # Gate purpose

    - id: publish  # Gate ID
      role: publisher      # Publisher role
      description: "Final publish"  # Gate purpose
```

Key observations:
- Same structure works for all domains
- Gates, roles, and rejection are universal concepts
- Conditional logic adapts workflow to task characteristics
- No domain-specific primitives in core abstraction

---

## 8. Observability Strategy

### 8.1 Operational Questions We Must Answer

1. **Bottlenecks:** Which gates have longest task dwell time?
2. **Rejection rates:** What % of tasks get rejected at each gate?
3. **Loop counts:** How many times does a task cycle through gates on average?
4. **Idle gates:** Are any gates underutilized (no tasks assigned)?
5. **Agent performance:** Which agents have fastest gate completion times?
6. **Workflow health:** Are rejection rates trending up (process degradation)?

### 8.2 Metrics Dashboard (Grafana)

**Panel 1: Gate Throughput**
- Line graph of tasks entering/exiting each gate per hour
- Identifies bottlenecks visually

**Panel 2: Gate Duration (Heatmap)**
- Heatmap of P50/P95/P99 duration by gate
- Color-coded: green <1h, yellow 1-4h, red >4h

**Panel 3: Rejection Rate**
- Bar chart of rejection % by gate
- Alert if >50% rejection at any gate

**Panel 4: Active Tasks by Gate**
- Gauge showing current task count per gate
- Identifies where work is piling up

**Panel 5: Loop-Back Frequency**
- Histogram of how many times tasks cycle through workflow
- 1 pass = ideal, >3 passes = process issue

### 8.3 Alerting Rules

```yaml
# Alert if tasks stuck in gate >24h
- alert: GateStalled                 # Alert name
  expr: aof_gate_duration_seconds{outcome="none"} > 86400  # Condition

# Alert if rejection rate >60% for any gate
- alert: HighRejectionRate           # Alert name
  expr: rate(aof_gate_rejections_total[1h]) / rate(aof_gate_transitions_total[1h]) > 0.6  # Condition

# Alert if gate has no available agents
- alert: GateBlocked                 # Alert name
  expr: aof_gate_blocked_no_agents > 0  # Condition
```

### 8.4 Debugging Stuck Tasks

**CLI tool:**
```bash
# Show task's gate history
aof task history AOF-abc

# Output:
# Gate: implement (backend)
#   Agent: agent-7
#   Duration: 4h 30m
#   Outcome: complete
#
# Gate: code-review (architect)
#   Agent: agent-3
#   Duration: 30m
#   Outcome: needs_review
#   Blockers:
#     - Missing error handling
#     - Low test coverage
#
# Gate: implement (backend) [CURRENT]
#   Agent: agent-7
#   Duration: 2h 15m (in progress)
#   Review context: 2 blockers from code-review
```

**Trace view in event log:**
```bash
# Follow task through event stream
aof events --task AOF-abc --type gate_transition

# Shows full timeline with agents, outcomes, durations
```

---

## 9. Edge Cases & Error Handling (C2: Guardrails with Helpful Errors)

**Core Principle:** Every invalid action produces an **actionable, teaching error message** — not a cryptic failure or silent ignore.

### 9.1 Invalid Outcome Value

**Scenario:** Agent calls `aof_task_complete` with invalid outcome.

**Input:**
```json
{
  "outcome": "done",
  "summary": "Finished the work"
}
```

**Error Response:**
```json
{
  "error": "invalid_outcome",
  "message": "Invalid outcome 'done'. Valid outcomes: 'complete', 'needs_review', 'blocked'.\n\nUse:\n- 'complete' if your work is finished and ready to advance\n- 'needs_review' if work needs revision (include specific blockers)\n- 'blocked' if you can't proceed due to external dependency\n\nExample:\n{\n  \"outcome\": \"complete\",\n  \"summary\": \"Implemented auth with tests\"\n}",
  "validOutcomes": ["complete", "needs_review", "blocked"]
}
```

### 9.2 Missing Required Summary

**Scenario:** Agent calls `aof_task_complete` without summary.

**Input:**
```json
{
  "outcome": "complete"
}
```

**Error Response:**
```json
{
  "error": "missing_summary",
  "message": "Missing required field 'summary'. Please include a 1-2 sentence description of what you did.\n\nExample:\n{\n  \"outcome\": \"complete\",\n  \"summary\": \"Implemented JWT middleware with error handling, 85% test coverage\"\n}"
}
```

### 9.3 Missing Blockers for needs_review/blocked

**Scenario:** Agent signals `needs_review` or `blocked` without listing blockers.

**Input:**
```json
{
  "outcome": "needs_review",
  "summary": "Implementation needs work"
}
```

**Error Response:**
```json
{
  "error": "missing_blockers",
  "message": "Outcome 'needs_review' requires 'blockers' field. List specific issues that need fixing.\n\nBe specific and actionable:\n✅ Good: \"Missing error handling for expired tokens\"\n✅ Good: \"Test coverage at 65%, need 80%\"\n❌ Bad: \"Needs work\"\n❌ Bad: \"Not good enough\"\n\nExample:\n{\n  \"outcome\": \"needs_review\",\n  \"summary\": \"Implementation needs revision\",\n  \"blockers\": [\n    \"Missing error handling for timeout edge case\",\n    \"Test coverage at 65%, target is 80%\"\n  ]\n}",
  "requiredField": "blockers"
}
```

### 9.4 Empty Blockers Array

**Scenario:** Agent provides `blockers: []` (empty array).

**Input:**
```json
{
  "outcome": "blocked",
  "summary": "Can't proceed",
  "blockers": []
}
```

**Error Response:**
```json
{
  "error": "empty_blockers",
  "message": "The 'blockers' array is empty. If outcome is 'needs_review' or 'blocked', list at least one specific issue.\n\nWhat's blocking progress? Be specific:\n- \"Waiting for API spec from platform team\"\n- \"Missing database migration for new schema\"\n- \"Need security review approval before proceeding\"\n\nExample:\n{\n  \"outcome\": \"blocked\",\n  \"summary\": \"Waiting for external dependency\",\n  \"blockers\": [\"Need finalized API spec from platform team\"]\n}"
}
```

### 9.5 Vague Blocker Text

**Scenario:** Agent provides non-actionable blocker.

**Input:**
```json
{
  "outcome": "needs_review",
  "summary": "Needs work",
  "blockers": ["needs improvement", "not good"]
}
```

**Warning Response** (soft validation, doesn't block):
```json
{
  "warning": "vague_blockers",
  "message": "Some blockers are vague and may not be actionable:\n- \"needs improvement\" - What specifically needs improvement?\n- \"not good\" - What exactly is wrong?\n\nBe specific so the implementer knows what to fix:\n✅ \"Missing error handling for expired tokens\"\n✅ \"Function 'authenticate' is 250 LOC, should be <120\"\n✅ \"Test coverage at 65%, target is 80%\"\n\nTask will proceed, but specific blockers help implementers fix issues faster.",
  "vagueBlockers": ["needs improvement", "not good"]
}
```

### 9.6 Wrong Task Completion

**Scenario:** Agent tries to complete task they're not assigned to.

**Context:** Agent assigned to AOF-abc, tries to complete AOF-xyz.

**Error Response:**
```json
{
  "error": "wrong_task",
  "message": "You're trying to complete task AOF-xyz, but you're currently assigned to task AOF-abc.\n\nDid you mean to complete AOF-abc?\n\nIf you need to work on a different task, use aof_task_get to receive your next assignment.",
  "assignedTask": "AOF-abc",
  "attemptedTask": "AOF-xyz"
}
```

### 9.7 No Agents for Role

**Scenario:** Gate requires role "security" but no agents have that role.

**System Behavior:**
1. Mark task as blocked
2. Set `task.blockers = ["No agents available for role: security"]`
3. Emit `gate_blocked_no_agents{role="security"}` metric
4. Send notification to project owner (if configured)

**Error Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "level": "error",
  "event": "gate_blocked_no_agents",
  "taskId": "AOF-abc",
  "gate": "security",
  "role": "security",
  "message": "Cannot route task AOF-abc to gate 'security': no agents available for role 'security'. Check org.yaml configuration."
}
```

**Agent-Visible Message** (when checking task status):
```
Task AOF-abc is blocked: No agents available for role 'security'. 
Please contact project owner to assign agents to this role in org.yaml.
```

### 9.8 Conditional Gate Expression Error

**Scenario:** Gate has `when: "metadata.foo.bar.baz"` but `metadata.foo` is undefined.

**System Behavior:**
1. Treat expression as falsy (skip gate)
2. Log warning with gate ID and expression
3. Continue to next gate
4. Do NOT block workflow on condition errors

**Warning Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "level": "warn",
  "event": "gate_condition_error",
  "taskId": "AOF-abc",
  "gate": "security",
  "expression": "metadata.foo.bar.baz",
  "error": "Cannot read property 'bar' of undefined",
  "action": "Skipping gate (treating condition as false)",
  "message": "Gate conditional expression failed for task AOF-abc at gate 'security'. Expression: 'metadata.foo.bar.baz' raised error: Cannot read property 'bar' of undefined. Treating as false and skipping gate."
}
```

### 9.9 Circular Rejection Loop

**Scenario:** Task bounces between gates infinitely (e.g., implement → review → implement → review → ...).

**Detection:**
- Count occurrences of each gate in `gateHistory`
- If any gate appears >5 times, flag as circular loop

**System Behavior:**
1. Mark task as blocked
2. Emit `gate_circular_loop` metric
3. Notify project owner for manual intervention
4. Do NOT auto-resolve (may mask real process issues)

**Error Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "level": "error",
  "event": "gate_circular_loop",
  "taskId": "AOF-abc",
  "gate": "code-review",
  "loopCount": 6,
  "message": "Task AOF-abc has entered gate 'code-review' 6 times, indicating a circular rejection loop. Task marked as blocked. Manual intervention required."
}
```

**Agent-Visible Message:**
```
Task AOF-abc is blocked due to circular rejection loop. 
The task has been rejected 6 times between 'implement' and 'code-review' gates.

This suggests:
- Blockers are unclear or impossible to satisfy
- Implementation and review expectations are misaligned
- There may be a bug or misconfiguration

Please contact project owner for manual review.
```

### 9.10 Agent Rejects at Non-Reviewable Gate

**Scenario:** Agent at gate with `canReject: false` returns `outcome: "needs_review"`.

**Error Response:**
```json
{
  "error": "reject_not_allowed",
  "message": "Gate 'implement' does not allow rejections (canReject: false). You cannot use outcome 'needs_review' at this gate.\n\nValid outcomes for this gate:\n- 'complete': Your work is done and ready to advance\n- 'blocked': You can't proceed due to external dependency\n\nIf your work has issues, mark it 'complete' anyway and let the next review gate catch problems. Or mark 'blocked' if you truly can't proceed.",
  "gate": "implement",
  "canReject": false,
  "validOutcomes": ["complete", "blocked"]
}
```

### 9.11 Human-Only Gate Attempted by Agent

**Scenario:** Agent tries to complete gate with `requireHuman: true`.

**Error Response:**
```json
{
  "error": "human_required",
  "message": "Gate 'approve' requires human approval (requireHuman: true). Agents cannot complete this gate.\n\nThis gate must be completed by a human agent (e.g., human-xav). If you are a human, ensure your agent ID is prefixed with 'human-' in the org chart.\n\nIf you believe this is an error, contact the project owner.",
  "gate": "approve",
  "requireHuman": true,
  "yourAgentId": "agent-7"
}
```

### 9.12 Gate Timeout (Auto-Escalation)

**Scenario:** Agent doesn't complete gate within timeout threshold.

**System Behavior:**
1. Unassign task from current agent
2. Route to escalation role (if specified)
3. Emit `gate_timeout` metric
4. Log escalation event

**Escalation Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "level": "warn",
  "event": "gate_timeout",
  "taskId": "AOF-abc",
  "gate": "code-review",
  "role": "architect",
  "agent": "agent-architect-1",
  "timeout": "1h",
  "escalateTo": "tech-lead",
  "message": "Task AOF-abc timed out at gate 'code-review' (agent: agent-architect-1, timeout: 1h). Escalating to role 'tech-lead'."
}
```

**Agent-Visible Message** (to original agent):
```
Task AOF-abc has been reassigned due to timeout.
You were assigned to 'code-review' gate but didn't complete within 1h.
Task has been escalated to 'tech-lead' role.

No action needed from you. If this was an error, contact project owner.
```

**Agent-Visible Message** (to escalation agent):
```
Task AOF-abc has been escalated to you from 'code-review' gate.
Original assignee: agent-architect-1 (timed out after 1h)

Please review and complete this task.
```

### 9.13 Task Assigned to Wrong Role

**Scenario:** Task routed to agent whose role doesn't match current gate.

**Detection:** `agent.role != gate.role`

**System Behavior:**
1. Unassign task from agent
2. Re-route to correct role's agents
3. Log `gate_assignment_error` metric
4. Notify misassigned agent

**Error Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00Z",
  "level": "error",
  "event": "gate_assignment_error",
  "taskId": "AOF-abc",
  "gate": "code-review",
  "expectedRole": "architect",
  "actualRole": "backend",
  "agent": "agent-7",
  "message": "Task AOF-abc at gate 'code-review' was assigned to agent 'agent-7' (role: backend), but gate requires role 'architect'. Reassigning to correct role."
}
```

**Agent-Visible Message:**
```
Task AOF-abc has been unassigned from you due to role mismatch.
Gate 'code-review' requires role 'architect', but your role is 'backend'.

This is likely a configuration error. Task has been reassigned to correct role.
```

### 9.14 Concurrent Gate Completions

**Scenario:** Two agents assigned to same gate (load balancing), both complete simultaneously.

**System Behavior (optimistic locking):**
1. First completion writes to task file (wins)
2. Second completion detects state change (task.gate.current != expected)
3. Second completion is discarded
4. Emit `gate_conflict` metric
5. Notify second agent

**Conflict Log:**
```json
{
  "timestamp": "2026-02-16T15:00:00.123Z",
  "level": "warn",
  "event": "gate_conflict",
  "taskId": "AOF-abc",
  "gate": "implement",
  "winningAgent": "agent-backend-1",
  "losingAgent": "agent-backend-2",
  "message": "Concurrent completion detected for task AOF-abc at gate 'implement'. Agent agent-backend-1 completed first. Agent agent-backend-2's completion discarded."
}
```

**Agent-Visible Message** (to losing agent):
```
Your completion of task AOF-abc was not recorded.
Another agent (agent-backend-1) completed the same task slightly earlier.

Task has already advanced to the next gate. No action needed from you.
```

### 9.15 Summary: Error Design Principles

Every error message follows these principles:

1. **State the problem clearly** - "You returned 'done', but valid outcomes are..."
2. **Explain why it's wrong** - "Gate 'implement' does not allow rejections because..."
3. **Show how to fix it** - "Use 'complete' if your work is finished, or..."
4. **Provide concrete examples** - Show valid JSON structure
5. **Never blame or shame** - Assume good intent, teach correct usage

**Success metric:** An agent that makes an error should understand how to fix it **without asking a human**.

---


## 10. Migration Path

### 10.1 Existing Tasks (Pre-Gates)

**Problem:** Tasks in flight have no gate metadata.

**Solution 1: Implicit gate injection**
- On first scheduler pass, detect tasks without `gate.current`
- Assign to first gate in project workflow
- Append synthetic gate history entry
- Continue normally

**Solution 2: Migration script**
```bash
# One-time migration
aof migrate tasks --add-gates --workflow default

# For each task:
#   - Add gate.current = workflow.gates[0].id
#   - Add gateHistory with synthetic entry
#   - Update routing.role to match first gate
```

**Recommendation:** Solution 1 (implicit) is simpler and requires no downtime.

### 10.2 Projects Without Workflows

**Scenario:** Project has no workflow defined in `project.yaml`.

**Fallback behavior:**
- Use single-gate default workflow:
  ```yaml
  workflow:
    gates:  # Ordered gate list
      - id: complete   # Single gate for projects without workflows
        role: default  # Default role (or task.routing.role)
  ```
- All tasks immediately complete after agent signals done
- No review gates, no rejection loops
- Equivalent to current AOF behavior

**Migration:**
- Projects opt-in by defining `workflow:` section in `project.yaml`
- Existing behavior preserved until workflow added

### 10.3 Workflow Config Changes Mid-Flight

**Scenario:** Workflow config changes while tasks are in gates.

**Strategy:**
1. **Gate still exists:** No change, tasks continue through updated workflow
2. **Gate removed:** Map tasks to nearest ancestor gate still in workflow
3. **Gate added:** Existing tasks skip new gate (they started on old config)
4. **Role changed:** Re-route task to new role's agents

**Implementation:**
- Scheduler detects config change (watch `project.yaml` mtime)
- Reload workflow config
- For each active task, validate `gate.current` still exists
- If not, log error and either auto-migrate or flag for manual intervention

**Safety:** Version workflow configs, store `workflowVersion` in task frontmatter to detect drift.

### 9.4 Backward Compatibility

**Guarantee:** Agents using current `aof_task_complete` API work unchanged.

**How:**
- If `outcome` field omitted, default to `"complete"`
- Existing completion handlers route through gate evaluation (transparently advance gate)
- Projects without workflows use single-gate fallback

**No breaking changes for agents.**

---


## 11. Open Questions & Future Work

### 11.1 Data Storage — **RESOLVED (D1)**

**Decision:** `gateHistory` lives in task frontmatter.

**Rationale:** Single source of truth, atomic updates, simpler queries. Long-running tasks with unbounded history can archive old entries to companion files if needed, but frontmatter is default.

### 11.2 Conditional Expression Language — **RESOLVED**

**Decision:** JavaScript expressions with safe eval sandbox.

**Rationale:** Flexibility for complex conditionals without inventing a DSL. Sandboxing prevents security issues. Whitelist safe operations.

### 11.3 Rejection Target Selection — **RESOLVED (D4)**

**Decision:** V1 uses simplified routing — all rejections go back to **implement** gate.

**Rationale:** Simpler for agents, covers 80%+ of use cases. Future versions can support more sophisticated routing (previous, origin, named) if patterns emerge.

### 11.4 Parallel Gates — **DEFERRED TO V2 (D5)**

**Question:** Should workflows support parallel gates (e.g., security + docs simultaneously)?

**Current design:** Sequential only in v1.

**Implication:** Parallel gates require fork/join logic, much higher complexity:
- How to wait for all parallel gates to complete
- How to handle if one rejects while others approve
- How to merge feedback from multiple reviewers

**Decision:** Defer to v2. V1 uses **conditional gates** (skip if not applicable) to reduce latency without fork/join complexity.

**Future design sketch:**
```yaml
gates:  # Ordered gate list
  - id: implement          # Implementation gate
    role: backend          # Role from org.yaml

  # Parallel review gates (v2 concept)
  - id: parallel-review    # Fork gate ID
    type: fork             # Fork/join type (future)
    branches:  # Parallel branches
      - id: security        # Branch gate ID
        role: security      # Security role
      - id: docs            # Branch gate ID
        role: tech-writer   # Docs role
    joinStrategy: all       # Wait for all branches (or any/majority)

  - id: approve            # Final approval gate
    role: po               # Product owner role
```

**Document in:** `~/Projects/AOF/docs/ROADMAP.md` or Future Work section below.

### 11.5 Gate Timeouts/SLAs — **RESOLVED (D2)**

**Decision:** Include in v1 with "dumb" auto-escalation.

**Values:**
- Review gates (code-review, QA, security, docs, po-accept): **1 hour**
- Implementation gate: **2 hours**
- Deploy: **45 min**
- Ready-check: **30 min**

**Mechanism:** Timeout → escalate to next in chain (specified via `escalateTo` field).

**Rationale:** Agents work continuously, not humans. 4hr timeouts are too generous. Dumb escalation prevents bottlenecks.

### 11.6 Human Approval Gates — **RESOLVED (D3)**

**Decision:** Include in v1 with `requireHuman: true` flag.

**Mechanism:**
- Gate config includes `requireHuman: true`
- Agents attempting to complete this gate receive error
- Only agents with ID prefix `human-*` can complete

**Use case:** PO acceptance, final sign-off, compliance gates.

### 11.7 Workflow Versioning — **RESOLVED**

**Decision:** Tasks always use latest workflow (dynamic).

**Rationale:** Simpler than version pinning, no version sprawl. Requires validation:
- When workflow changes, check in-flight tasks
- If task's current gate no longer exists, migrate to nearest valid gate or flag for manual intervention

**Implementation:** Store workflow hash in task frontmatter, detect drift on scheduler pass.

### 11.8 Self-Review Gate (Same Agent Type, Fresh Session) — **FUTURE (V2)**

**What:** Before architect code-review, have another instance of the same agent type review in a fresh session.

**Why:** Fresh eyes catch different issues than original implementer (author blindness).

**Challenge:** May be hard to accomplish through plugin or plain AOF — needs design.

**Value:** High — catches mistakes before expensive architect review.

**Document in:** Wishlist / V2 section below.

---

## 12. Future Work (Post-V1)

### 12.1 Parallel Gates (D5)

**Description:** Run security + docs + QA simultaneously instead of sequentially.

**Complexity:** Fork/join logic, conflict resolution, multi-reviewer feedback merging.

**Workaround in V1:** Use conditional gates (skip if not applicable).

**Priority:** Medium (latency not a concern right now).

### 12.2 Self-Review Gate

**Description:** Same agent type, different session reviews work before passing to next gate.

**Use case:** Catch author blindness before expensive architect review.

**Challenge:** Requires fresh session with no memory of original implementation.

**Priority:** High value, hard to implement.

### 12.3 Human-in-the-Loop Pairing

**Description:** Allow humans to pair with agents OR fulfill an entire role interactively.

**Use cases:** Training new agents, high-stakes decisions, creative work.

**Challenge:** Needs mechanism to pause workflow and wait for human input.

**Priority:** Medium (niche use case).

### 12.4 BDD Test Execution Integration

**Description:** V1 includes BDD-style test specs in task frontmatter. V2 could execute them automatically.

**What's needed:**
- Test runner that parses `tests[]` from frontmatter
- HTTP client for API tests
- Assertion engine for `then` clauses

**Value:** Automatic validation of acceptance criteria.

**Priority:** Low (manual testing works for v1).

### 11.5 Advanced Metrics & Observability

**Description:** DORA metrics, gate-specific analytics, agent performance tracking.

**Challenge:** Must be platform-agnostic. Can't inject custom instructions into platform agents easily.

**Approach:** AOF already emits JSONL events. A dedicated metrics agent could analyze these.

**Priority:** Medium (observability first, analysis later).

---

## 13. Implementation Phases

### Phase 1: Core Primitive (MVP)
**Goal:** Basic gate progression with simple rejection loops, timeouts, and human-only gates (v1 scope).

**Scope:**
- Sequential gates (no conditionals yet)
- Forward progression (advance to next gate)
- Simplified rejection routing (D4: all rejections → implement)
- Gate timeouts + dumb auto-escalation (D2: 1hr review, 2hr implement)
- Human-only gates (`requireHuman: true`) (D3)
- Basic telemetry (gate_duration, gate_transitions_total, gate_timeout)
- Config validation
- Gate history in frontmatter (D1)

**Deliverables:**
- Task frontmatter schema with `gateHistory[]`, `tests[]`, and optional `testsFile`
- Workflow config schema with inline documentation (timeout + escalation fields)
- Gate evaluation algorithm (section 3.1, simplified)
- Scheduler integration (section 6.1)
- 2-3 example workflows with comments
- Tool description for `aof_task_complete` (self-teaching)

**Acceptance:**
- Task progresses implement → review → approve automatically
- Review can reject back to implement with blockers
- Agent sees review feedback in `reviewContext`
- Tasks auto-escalate after timeout threshold
- Human-only gates reject agent completion attempts
- Telemetry shows gate durations and timeouts
- Agents use tool successfully with zero training

**Out of scope:**
- Conditional gates (`when` expressions)
- Advanced rejection routing (previous/origin/named)
- Parallel gates (fork/join)

### Phase 2: Conditional Gates
**Goal:** Skip optional gates based on task metadata.

**Scope:**
- `when` expression support (conditional gate activation)
- JavaScript sandbox for eval
- Gate skip logging
- Expression validation

**Deliverables:**
- Expression evaluator with sandboxing
- Config validation for `when` clauses
- Updated telemetry (gate_skips_total)

**Acceptance:**
- Security gate skipped for non-security tasks
- Docs gate skipped for non-API tasks
- Expression errors handled gracefully (gate skipped)

### Phase 3: Self-Documenting Config + Org Chart
**Goal:** Make configuration readable without external docs.

**Scope:**
- Add inline comments to all config examples (C3)
- Org chart integration with full documentation (C5)
- Org chart validation (roles exist, agents exist)
- Org chart reload mechanism
- Assignment patterns documented (single agent, multiple, escalation)

**Deliverables:**
- `org.yaml` schema with inline comments
- Org chart parser and validator
- Role → agents mapping in scheduler
- Documentation: adding/removing agents, role patterns
- Validation error messages for missing roles/agents

**Acceptance:**
- Human can read `project.yaml` and `org.yaml` without docs
- Scheduler routes tasks to correct agents via role mapping
- Missing role produces helpful error message
- Empty role marks tasks as blocked (no silent failures)

### Phase 4: Helpful Errors (C2)
**Goal:** Every invalid action produces actionable, teaching error message.

**Scope:**
- Error catalog for all invalid inputs (section 9)
- Validation layer in `aof_task_complete`
- Helpful error responses with examples
- Soft warnings for vague blockers

**Deliverables:**
- Error response schema
- Validation functions for outcomes, summaries, blockers
- Error messages with teaching content
- Test suite for error cases

**Acceptance:**
- Invalid outcome → specific error with valid options
- Missing summary → error with example
- Missing blockers → error with good vs. bad examples
- Wrong task → error with assigned task ID
- Vague blocker → warning (not blocking) with improvement suggestions

### Phase 5: Observability & Tooling
**Goal:** Full operational visibility into gate health.

**Scope:**
- Complete metric set (section 7.2)
- Grafana dashboard
- CLI tools for debugging (task history, gate status)
- Alerting rules
- Event stream logging (JSONL)

**Deliverables:**
- Prometheus metrics exporter
- Grafana dashboard JSON
- `aof task history` command
- `aof gate status` command
- Alert rule templates (stuck tasks, high rejection rates)

**Acceptance:**
- Dashboard shows gate bottlenecks in real-time
- Alerts fire for stuck tasks or circular loops
- CLI tools help debug gate issues
- Event log provides full audit trail

### Phase 6: Advanced Features (Post-MVP / V2)
**Scope:**
- Parallel gates (fork/join logic) — see section 11.1
- Self-review gates (fresh session) — see section 11.2
- Human-in-the-loop pairing — see section 11.3
- BDD test execution — see section 11.4
- Advanced metrics/analytics — see section 11.5

---

## 14. Success Criteria

### 12.1 Agent Simplicity
✅ Agents call `aof_task_complete` with no workflow knowledge
✅ No manual routing or gate selection by agents
✅ Review feedback appears automatically in task context

### 12.2 Human Simplicity
✅ Basic workflow defined in ~10 lines of YAML
✅ No workflow engine "programming" — declarative config only
✅ Config errors caught at load time, not runtime

### 12.3 Domain Neutrality
✅ Works for SWE, sales, content, compliance workflows
✅ No software-specific terms in core abstractions
✅ Same primitive serves all domains

### 12.4 Determinism
✅ Gate routing is pure TypeScript (no LLM calls in scheduler)
✅ Same outcome produces same transition (idempotent)
✅ Config changes are predictable (no emergent behavior)

### 12.5 Observability
✅ Every gate transition logged and metrified
✅ Bottlenecks visible in real-time dashboard
✅ Historical trends for rejection rates, durations, etc.

---

## 15. Next Steps

1. **Review this design:** PO, PM, and lead architect validate abstractions and constraints
2. **Prototype gate evaluator:** Build core algorithm (section 3.1) in isolation, validate with test cases
3. **Define schema:** Finalize task frontmatter and workflow config (section 2)
4. **Spike conditional expressions:** Test JavaScript sandbox for `when` clauses, measure performance
5. **Design telemetry schema:** Lock down metric names and labels (section 7)
6. **Decompose into tasks:** Create AOF tasks for Phase 1 implementation
7. **Implementation:** swe-backend implements core, swe-qa validates with test workflows

---

## Appendix A: Workflow Config Full Schema

```yaml
workflow:  # Workflow definition
  # Workflow identifier (allows multiple workflows per project)
  name: string  # e.g., "default"

  # Description for documentation
  description: string  # Human-readable workflow summary

  # Default outcome if agent doesn't specify (rarely needed)
  defaultOutcome: "complete" | "needs_review" | "blocked"  # Fallback outcome

  # Rejection loop-back strategy (D4: v1 routes to implement)
  rejectionStrategy: "origin"  # Always return to first gate in v1

  # Gate definitions (ordered sequence - tasks progress through in order)
  gates:  # Ordered gate list
    - id: string                    # Unique within workflow (e.g., "implement", "review")
      role: string                  # Maps to org chart role (e.g., "backend", "architect")
      description: string           # Human-readable purpose (shown to agents)
      canReject: boolean            # Can this gate send work back? (default: false)
      when: string                  # Optional JS expression for conditional activation
      requireHuman: boolean         # Must a human approve (not agent)? (D3, default: false)
      timeout: string               # Max duration before auto-escalation (e.g., "1h", "2h") (D2)
      escalateTo: string            # Role to escalate to on timeout (must exist in org chart)
      metadata: Record<string, any> # Custom gate metadata (for advanced use cases)
```

## Appendix B: Task Frontmatter Full Schema

```yaml
# Unique task identifier (generated by AOF)
id: string  # Immutable task ID

# Human-readable title
title: string  # Short task name

# Detailed description of what needs to be done
description: string  # Full task description

# Task lifecycle status
status: "ready" | "in_progress" | "blocked" | "complete"  # Lifecycle state

# Timestamps
created: ISO8601  # Creation time
updated: ISO8601  # Last update time

# Routing information (determines assignment)
routing:  # Routing info
  workflow: string    # Workflow name from project.yaml
  role: string        # Current gate's role (used for agent assignment)
  agent: string       # Currently assigned agent ID (if any)

# Current gate state
gate:  # Current gate state
  current: string     # Current gate ID (matches workflow gate)
  entered: ISO8601    # When task entered this gate (for timeout detection)

# Complete audit trail of all gate transitions (D1: stored in frontmatter)
# Append-only log - never delete entries
gateHistory:  # Append-only audit trail
  - gate: string              # Gate ID
    role: string              # Gate's assigned role
    agent: string             # Agent who worked on this gate
    entered: ISO8601          # When agent entered gate
    exited: ISO8601           # When agent completed gate
    outcome: "complete" | "needs_review" | "blocked"  # Result
    summary: string           # Agent's completion summary
    blockers: string[]        # If outcome = needs_review or blocked
    rejectionNotes: string    # If outcome = needs_review (additional context)
    duration: number          # Seconds spent in gate (for metrics)

# Review context (present if looped back from rejection)
# Provides feedback to agent on what to fix
reviewContext:  # Review feedback
  fromGate: string    # Gate that rejected (e.g., "code-review")
  fromAgent: string   # Agent who rejected
  fromRole: string    # Role of rejecting agent
  timestamp: ISO8601  # When rejection occurred
  blockers: string[]  # Copied from rejection outcome (actionable issues)
  notes: string       # Copied from rejectionNotes (additional guidance)

# Optional: BDD-style test specifications (C6: designed for future executability)
# If tests grow beyond ~20 specs, move to companion file with testsFile reference
tests:  # Optional BDD-style test specs
  - given: string     # Precondition (e.g., "Valid JWT token in Authorization header")
    when: string      # Action (e.g., "POST /api/protected")
    then:  # Expected outcomes
      status: number            # Expected HTTP status code
      body_contains: string[]   # Expected strings in response body
      headers: Record<string, string>  # Expected response headers (optional)

# Alternative: reference external test file
# testsFile: string   # Path to TASK-xxx.tests.yaml (if tests too large)

# Task classification (used in gate conditionals)
tags: string[]  # Tag list used by gate conditionals

# Free-form metadata (available in gate when expressions)
metadata: Record<string, any>  # Arbitrary metadata for conditions/telemetry
```

## Appendix C: Outcome Schema

```typescript
interface GateOutcome {
  outcome: "complete" | "needs_review" | "blocked" | "skip";
  summary: string;                      // Human-readable completion summary
  blockers?: string[];                  // For needs_review or blocked
  rejectionNotes?: string;              // For needs_review
  metadata?: Record<string, any>;       // Custom telemetry data
}
```

---

**End of Design Document**

**Status:** Ready for PO/PM review  
**Next:** Review meeting, address open questions, prototype gate evaluator
